# Trade_core

Торговое ядро. Периодически получает последние [биржевые стаканы](https://ru.wikipedia.org/wiki/Биржевой_стакан) и
информацию о балансе связанного шлюза. На их основе принимает решения о выставлении или отмене ордеров и отправляет
соответствующие команды в шлюз.

## Принцип работы

Цель ядра — держать все деньги в лимит-ордерах, в некотором отдалении
от [спреда](https://ru.wikipedia.org/wiki/Спред_(финансы)).

После получения информации о балансе ядро выставляет лимит-ордера на все доступные средства. Цена ордера на покупку
ставится выше текущего лучшего предложения, цена на продажу — ниже.

В момент выставления каждого ордера рассчитываются также _границы удержания_. Это границы, в пределах которых может
колебаться лучшая цена ([аск](https://ru.wikipedia.org/wiki/Аск_(цена)) или [бид](https://ru.wikipedia.org/wiki/Бид)).
Как только лучшая цена выходит за установленные пределы, связанный ордер отменяется, все значения пересчитываются, и
ордер выставляется заново.

Например:

![Ордер на продажу](https://user-images.githubusercontent.com/44947427/152686343-cb49a57c-22bb-41ce-a875-cddcd0bbcedf.svg)

> Границы нужны для того, чтобы снизить частоту выставления ордеров. Если они будут слишком узкими, то ордера будут
> перерассчитываться почти на каждом обновление стакана, и биржа может заблокировать шлюз

## Установка и сборка

Первое, что вам необходимо сделать — собрать [Boost](https://ru.wikipedia.org/wiki/Boost) 1.78.0, включая компонент
Boost.Log. Вы можете найти подробные инструкции на официальном сайте в
разделе [Getting Started on Unix Variants](https://www.boost.org/doc/libs/1_78_0/more/getting_started/unix-variants.html).

Затем можете клонировать код репозитория:

```shell
git clone --recurse-submodules https://github.com/RoboTradeCode/simple-core.git
```

> Обратите внимание на параметр `--recurse-submodules`. Он нужен, чтобы рекурсивно установить все зависимости
> репозитория, описанные в файле [.gitmodules](.gitmodules)

Сборка осуществляется с использованием утилиты [CMake](https://ru.wikipedia.org/wiki/CMake). Для её упрощения вы можете
воспользоваться скриптом [build.sh](build.sh). После его исполнения собранный код будет находиться в директории
build/Debug:

```shell
./build.sh
```
Исполняемый файл будет находиться в папке build/Release. Для запуска в терминале выполнить ./trade_core, предварительно сконфигурировав
файл default_config.toml

### Подготовка к запуску

Всю необходимую для работы информацию ядро получает из файла default_config.toml

Пример файла default_config.toml

```toml
# данные для гейта
[core]
exchange_name = 'exchange_name'
instance_name = '1'
[configuration]
# Откуда загружать конфигурацию. Может быть три значения: agent, api, file.

source = 'api'

# эндпойнт для получения конфигурации от конфигуратора.
api = ["configurator.robotrade.io", "/{exchange_name}/1?only_new=false"]

# настройки работы протокола aeron
[aeron]
# настройки каналов откуда будем принимать данные
[aeron.subscribers]
# настройки канала куда будет приходить конфигурацию от агента
# ["channel", channel_id]       
agent = ["aeron:ipc", 1004]
# настройки каналов куда будем отправлять данные
[aeron.publishers]
# канал куда отправляем логи
logs = ["aeron:ipc", 2002]
# канал агента куда гейт при запуске отправит запрос на получение конфига
agent = ["aeron:ipc", 1002]
```
Поле "source" может иметь три значения:

 - agent (конфигурация будет получена от агента по каналу aeron);
 - api   (конфигурация будет получена непосредственно с сервера конфигуратора (как настроить файл конфигурации смотреть [тут](https://github.com/RoboTradeCode/simple-core/wiki/Core-Configuration)), будет использоваться эндпойнт из примера выше)
 - file  (конфигурация будет получена из файла config.json (настраивается так же, как и на сервере конфигуратора), который должен находиться там же где и default_config.toml)
### Конфигурация ядра

Конфигурация хранится в файле [config.toml](config.toml.example) в формате [TOML](https://ru.wikipedia.org/wiki/TOML).
Ядро будет искать её по относительному пути в рабочей директории. В процессе сборки конфигурация автоматически
копируется к исполняемому файлу.

### Пример конфигурации systemd

Для настройки автоматического перезапуска кода можно запустить его в качестве
сервиса [systemd](https://ru.wikipedia.org/wiki/Systemd). Если имя вашего пользователя `ubuntu`, конфигурация может
выглядеть следующим образом:

```
[Unit]
Description=Trade Core
After=network.target

[Service]
User=ubuntu
WorkingDirectory=/home/ubuntu/trade_core/build/Debug
ExecStart=/home/ubuntu/trade_core/build/Debug/trade_core
Restart=always
RestartSec=3

[Install]
WantedBy=multi-user.target
```

## Логирование

В процессе своей работы ядро генерирует следующие файлы логов:

| Файл                | Содержимое                                                                |
|---------------------|---------------------------------------------------------------------------|
| logs/general.log    | Основные действия при работе ядра                                         |
| logs/balances.log   | Сообщения, поступившие на канал `balances` (баланс связанного шлюза)      |
| logs/orders.log     | Сообщения, которые ядро отправляет в связанный шлюз (ордера)              |
| logs/logs.log       | Сообщения, которые ядро отправляет в лог сервер                           |
| logs/errors.log     | Сообщения об ошибках                                                     |

Содержимое файлов logs/orders.log и logs/general.log для удобства дублируется на стандартный поток вывода.

## Алгоритм работы

Входные данные (на примере BTC/USDT):
- пороговые значения: 
    - btc_threshold  = 0.0008
    - usdt_threshold = 40

- коэффициенты для вычисления цены ордеров:
    - sell_ratio = 1.0015
    - buy_ratio  = 0.9985

- коэффициенты для вычисления границ удержания ордеров:
    - lower_bound_ratio  = 0.9995
    - uppder_bound_ratio = 1.0005

Действия:
1. Подписывается на канал aeron для получения балансов.
2. Подписывается на канал aeron для получения ордербуков.
3. Подписывается на канад aeron для получения статуса ордеров.
4. Посылает команду гейту на отмену всех ордеров.
5. Посылает команду гейту на получение баланса.
6. Получает информацию об ордербуках от гейта (или гейтов) и сохраняет ордербуки в словарь,
   ```
     например: std::map<std::string, std::map<std::string, std::pair<double, double>>> _orderbooks, 
   ```
     ключем которого является биржа (например "ftx"), а значением является тоже словарь, у которого ключ - валютная пара (например "BTC/USDT"), а значением является лучшее ценовое предложение (ask и bid).
7. Получает баланс и запоминает его в словаре, 
   ```
     например:  std::map<std::string, double> _balance, 
   ```
   ключом которого является accет (BTC, USD и т.д.), а значением являются доступные средства (поле free из json).
8. Вычисляет среднее арифметическое значение ордербуков **avg_ask** и **avg_bid** по конкретной валютной паре (например "BTC/USDT"), т.е. суммируем все ценовые предложения (ask и bid) по отдельности и делит сумму на количество ценовых предложений в валютной паре.
9. Из полученных средних значений выполняет рассчет возможных ордеров по формуле:
    ```
    sell_price = avg_ask * sell_ratio;
    buy_price  = avg_bid * buy_ratio;
    ```
10. Рассчитывает минимальные и максимальные границы из средних значений по формулам:
    ```
    min_ask = avg_ask * lower_bound_ratio;
    max_ask = avg_ask * upper_bound_ratio;
    min_ask = avg_bid * lower_bound_ratio;
    max_ask = avg_bid * upper_bound_ratio;
    ```
11. Проверяет, есть ли выставленный ордер на продажу и если нет ордера и есть достаточно BTC (т.е. **_balance["BTC"] > btc_threshold**), то выставлят ордер на продажу по цене **sell_price** и объемом **sell_quantity**, где **sell_quantity** - это доступные средства (см. п.6). После чего ядро запоминает значения **min_ask** и **max_ask** (граница удержания).
12. В канале статуса ордеров получает результат выставления ордера и запоминает идентификатор выставленного ордера.
13. Проверяет, есть ли выставленный ордер на покупку и если нет ордера и есть достаточно USDT (т.е. **_balance["USDT"] > usdt_threshold**), то выставлят ордер на покупку по цене **buy_price** и объемом **buy_quantity**, где **buy_quantity** - это значение, вычисленное по формуле: 
```
  buy_quantity = _balance["USDT"] / sell_price. 
```  
  После чего ядро ядро запоминает значения **min_bid** и **max_bid** (граница удержания).
14. В канале статуса ордеров получает результат выставления ордеа и запоминает идентификатор выставленного ордера.  


15. Если есть выставленный ордер на продажу, но усредненное лучшее предложение (**avg_ask**) за пределами границы удержания (т.е. данное условие не выполняется: **(min_ask < avg_ask && avg_ask < max_ask)**), то ядро отменят ордер на покупку по раннее запомненному идентификатору.

16. Если есть выставленный ордер на покупку, но усредненное лучшее предложение (**avg_bid**) за пределами границы удержания (т.е. данное условие не выполняется: **(min_bid < avg_bid && avg_bid < max_bid)**), то ядро отменят ордер на продажу по ранее запомненному идентификатору.

17. Возвращается к пункту 6.


#### Блок-схема:
![trade_core](https://user-images.githubusercontent.com/60933744/170728197-693c95eb-d5e3-4aa6-be93-f18466ceee48.jpeg)


