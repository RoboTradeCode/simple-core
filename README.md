# Trade_core

Торговое ядро. Периодически получает последние [биржевые стаканы](https://ru.wikipedia.org/wiki/Биржевой_стакан) и
информацию о балансе связанного шлюза. На их основе принимает решения о выставлении или отмене ордеров и отправляет
соответствующие команды в шлюз.

## Принцип работы

Цель ядра — держать все деньги в лимит-ордерах, в некотором отдалении
от [спреда](https://ru.wikipedia.org/wiki/Спред_(финансы)).

После получения информации о балансе ядро выставляет лимит-ордера на все доступные средства. Цена ордера на покупку
ставится выше текущего лучшего предложения, цена на продажу — ниже.

В момент выставления каждого ордера рассчитываются также _границы удержания_. Это границы, в пределах которых может
колебаться лучшая цена ([аск](https://ru.wikipedia.org/wiki/Аск_(цена)) или [бид](https://ru.wikipedia.org/wiki/Бид)).
Как только лучшая цена выходит за установленные пределы, связанный ордер отменяется, все значения пересчитываются, и
ордер выставляется заново.

Например:

![Ордер на продажу](https://user-images.githubusercontent.com/44947427/152686343-cb49a57c-22bb-41ce-a875-cddcd0bbcedf.svg)

> Границы нужны для того, чтобы снизить частоту выставления ордеров. Если они будут слишком узкими, то ордера будут
> перерассчитываться почти на каждом обновление стакана, и биржа может заблокировать шлюз

## Установка и сборка

Первое, что вам необходимо сделать — собрать [Boost](https://ru.wikipedia.org/wiki/Boost) 1.78.0, включая компонент
Boost.Log. Вы можете найти подробные инструкции на официальном сайте в
разделе [Getting Started on Unix Variants](https://www.boost.org/doc/libs/1_78_0/more/getting_started/unix-variants.html).

Затем можете клонировать код репозитория:

```shell
git clone --recurse-submodules https://github.com/RoboTradeCode/simple-core.git
```

> Обратите внимание на параметр `--recurse-submodules`. Он нужен, чтобы рекурсивно установить все зависимости
> репозитория, описанные в файле [.gitmodules](.gitmodules)

Сборка осуществляется с использованием утилиты [CMake](https://ru.wikipedia.org/wiki/CMake). Для её упрощения вы можете
воспользоваться скриптом [build.sh](build.sh). После его исполнения собранный код будет находиться в директории
build/Debug:

```shell
./build.sh
```

### Конфигурация ядра

Конфигурация хранится в файле [config.toml](config.toml.example) в формате [TOML](https://ru.wikipedia.org/wiki/TOML).
Ядро будет искать её по относительному пути в рабочей директории. В процессе сборки конфигурация автоматически
копируется к исполняемому файлу.

| Параметр                 | Описание                                                                            | Значение по умолчанию                                                      |
|--------------------------|-------------------------------------------------------------------------------------|----------------------------------------------------------------------------|
| `btc_threshold`          | Пороговое значение BTC, с которого ядро начинает торговать                          | `"0.0008"`                                                                 |
| `usdt_threshold`         | Пороговое значение USDT, с которого ядро начинает торговать                         | `"40"`                                                                     |
| `sell_ratio`             | Коэффициент, на который умножается аск при вычислении цены ордера на продажу        | `"1.0015"`                                                                 |
| `buy_ratio`              | Коэффициент, на который умножается бид при вычислении цены ордера на покупку        | `"0.9985"`                                                                 |
| `lower_bound_ratio`      | Коэффициент, на который умножается аск/бид при вычислении нижней границы удержания  | `"0.9995"`                                                                 |
| `upper_bound_ratio`      | Коэффициент, на который умножается аск/бид при вычислении верхней границы удержания | `"1.0005"`                                                                 |
| `subscribers.*.channel`  | Канал для Aeron Subscriber                                                          | `"aeron:ipc"`                                                              |
| `publishers.*.channel`   | Канал для Aeron Publisher                                                           | <code>"aeron:ipc?control=localhost:40456&#124;control-mode=dynamic"</code> |
| `destinations`           | Список каналов Aeron, которые будут добавлены через метод `addDestination`          | `[]`                                                                       |
| `orderbooks.stream_id`   | Идентификатор потока для канала, по которому принимается биржевой стакан            | `1001`                                                                     |
| `balance.stream_id`      | Идентификатор потока для канала, по которому принимается баланс                     | `1002`                                                                     |
| `gateway.stream_id`      | Идентификатор потока для канала, на который отправляются ордера                     | `1003`                                                                     |
| `metrics.stream_id`      | Идентификатор потока для канала, на который отправляются метрики                    | `1004`                                                                     |
| `errors.stream_id`       | Идентификатор потока для канала, на который отправляются ошибки                     | `1005`                                                                     |
| `idle_strategy_sleep_ms` | Продолжительность для стратегии ожидания Aeron в мс                                 | `1`                                                                        |
| `buffer_size`            | Размер буфера                                                                       | `1400`                                                                     |

### Пример конфигурации systemd

Для настройки автоматического перезапуска кода можно запустить его в качестве
сервиса [systemd](https://ru.wikipedia.org/wiki/Systemd). Если имя вашего пользователя `ubuntu`, конфигурация может
выглядеть следующим образом:

```
[Unit]
Description=Trade Core
After=network.target

[Service]
User=ubuntu
WorkingDirectory=/home/ubuntu/trade_core/build/Debug
ExecStart=/home/ubuntu/trade_core/build/Debug/trade_core
Restart=always
RestartSec=3

[Install]
WantedBy=multi-user.target
```

## Логирование

В процессе своей работы ядро генерирует следующие файлы логов:

| Файл                | Содержимое                                                                |
|---------------------|---------------------------------------------------------------------------|
| logs/orderbooks.log | Сообщения, поступившие на канал `orderbooks` (биржевые стаканы от шлюзов) |
| logs/balance.log    | Сообщения, поступившие на канал `balances` (баланс связанного шлюза)      |
| logs/orders.log     | Сообщения, которые ядро отправляет в связанный шлюз (ордера)              |
| logs/errors.log     | Сообщения, которые ядро отправляет в канал ошибок                         |

Содержимое файла logs/orders.log для удобства дублируется на стандартный поток вывода.

## Мониторинг

Для удобства отслеживания ошибок в файле [main.cpp](src/main.cpp) подключён мониторинг
от [Sentry](https://sentry.io/welcome/). Вы можете указать своё значение DSN, изменив константу `SENTRY_DSN`.

Мониторинг будет фиксировать все возникающие ошибки и отправлять их на сервер. По возможности будут прикладываться файлы
логов и конфигурация.

> Если в коде произошла фатальная ошибка, она отправится только при следующем запуске ядра. Поэтому рекомендуется
> настроить автоматический перезапуск

## Алгоритм работы

Входные данные (на примере BTC/USDT):
- пороговые значения: 
    - btc_threshold  = 0.0008
    - usdt_threshold = 40

- коэффициенты для вычисления цены ордеров:
    - sell_ratio = 1.0015
    - buy_ratio  = 0.9985

- коэффициенты для вычисления границ удержания ордеров:
    - lower_bound_ratio  = 0.9995
    - uppder_bound_ratio = 1.0005

Действия:
1. Подписывается на канал aeron для получения балансов.
2. Подписывается на канал aeron для получения ордербуков.
3. Подписывается на канад aeron для получения статуса ордеров.
4. Посылает команду гейту на отмену всех ордеров.
5. Посылает команду гейту на получение баланса.
6. Получает информацию об ордербуках от гейта (или гейтов) и сохраняет ордербуки в словарь,
   ```
     например: std::map<std::string, std::map<std::string, std::pair<double, double>>> _orderbooks, 
   ```
     ключем которого является биржа (например "ftx"), а значением является тоже словарь, у которого ключ - валютная пара (например "BTC/USDT"), а значением является лучшее ценовое предложение (ask и bid).
7. Получает баланс и запоминает его в словаре, 
   ```
     например:  std::map<std::string, double> _balance, 
   ```
   ключом которого является accет (BTC, USD и т.д.), а значением являются доступные средства (поле free из json).
8. Вычисляет среднее арифметическое значение ордербуков **avg_ask** и **avg_bid** по конкретной валютной паре (например "BTC/USDT"), т.е. суммируем все ценовые предложения (ask и bid) по отдельности и делит сумму на количество ценовых предложений в валютной паре.
9. Из полученных средних значений выполняет рассчет возможных ордеров по формуле:
    ```
    sell_price = avg_ask * sell_ratio;
    buy_price  = avg_bid * buy_ratio;
    ```
10. Рассчитывает минимальные и максимальные границы из средних значений по формулам:
    ```
    min_ask = avg_ask * lower_bound_ratio;
    max_ask = avg_ask * upper_bound_ratio;
    min_ask = avg_bid * lower_bound_ratio;
    max_ask = avg_bid * upper_bound_ratio;
    ```
11. Проверяет, есть ли выставленный ордер на продажу и если нет ордера и есть достаточно BTC (т.е. **_balance["BTC"] > btc_threshold**), то выставлят ордер на продажу по цене **sell_price** и объемом **sell_quantity**, где **sell_quantity** - это доступные средства (см. п.6). После чего ядро запоминает значения **min_ask** и **max_ask** (граница удержания).
12. В канале статуса ордеров получает результат выставления ордера и запоминает идентификатор выставленного ордера.
13. Проверяет, есть ли выставленный ордер на покупку и если нет ордера и есть достаточно USDT (т.е. **_balance["USDT"] > usdt_threshold**), то выставлят ордер на покупку по цене **buy_price** и объемом **buy_quantity**, где **buy_quantity** - это значение, вычисленное по формуле: 
```
  buy_quantity = _balance["USDT"] / sell_price. 
```  
  После чего ядро ядро запоминает значения **min_bid** и **max_bid** (граница удержания).
14. В канале статуса ордеров получает результат выставления ордеа и запоминает идентификатор выставленного ордера.  


15. Если есть выставленный ордер на продажу, но усредненное лучшее предложение (**avg_ask**) за пределами границы удержания (т.е. данное условие не выполняется: **(min_ask < avg_ask && avg_ask < max_ask)**), то ядро отменят ордер на покупку по раннее запомненному идентификатору.

16. Если есть выставленный ордер на покупку, но усредненное лучшее предложение (**avg_bid**) за пределами границы удержания (т.е. данное условие не выполняется: **(min_bid < avg_bid && avg_bid < max_bid)**), то ядро отменят ордер на продажу по ранее запомненному идентификатору.

17. Возвращается к пункту 6.


#### Блок-схема:
![trade_core](https://user-images.githubusercontent.com/60933744/170728197-693c95eb-d5e3-4aa6-be93-f18466ceee48.jpeg)


