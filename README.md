# Trade_core

Торговое ядро. Периодически получает последние [биржевые стаканы](https://ru.wikipedia.org/wiki/Биржевой_стакан) и
информацию о балансе связанного шлюза. На их основе принимает решения о выставлении или отмене ордеров и отправляет
соответствующие команды в шлюз.

## Принцип работы

Цель ядра — держать все деньги в лимит-ордерах, в некотором отдалении
от [спреда](https://ru.wikipedia.org/wiki/Спред_(финансы)).

После получения информации о балансе ядро выставляет лимит-ордера на все доступные средства. Цена ордера на покупку
ставится выше текущего лучшего предложения, цена на продажу — ниже.

В момент выставления каждого ордера рассчитываются также _границы удержания_. Это границы, в пределах которых может
колебаться лучшая цена ([аск](https://ru.wikipedia.org/wiki/Аск_(цена)) или [бид](https://ru.wikipedia.org/wiki/Бид)).
Как только лучшая цена выходит за установленные пределы, связанный ордер отменяется, все значения пересчитываются, и
ордер выставляется заново.

Например:

![Ордер на продажу](https://user-images.githubusercontent.com/44947427/152686343-cb49a57c-22bb-41ce-a875-cddcd0bbcedf.svg)

> Границы нужны для того, чтобы снизить частоту выставления ордеров. Если они будут слишком узкими, то ордера будут
> перерассчитываться почти на каждом обновление стакана, и биржа может заблокировать шлюз

## Установка и сборка

Первое, что вам необходимо сделать — собрать [Boost](https://ru.wikipedia.org/wiki/Boost) 1.78.0, включая компонент
Boost.Log. Вы можете найти подробные инструкции на официальном сайте в
разделе [Getting Started on Unix Variants](https://www.boost.org/doc/libs/1_78_0/more/getting_started/unix-variants.html).

Затем можете клонировать код репозитория:

```shell
git clone --recurse-submodules https://github.com/RoboTradeCode/simple-core.git
```

> Обратите внимание на параметр `--recurse-submodules`. Он нужен, чтобы рекурсивно установить все зависимости
> репозитория, описанные в файле [.gitmodules](.gitmodules)

Сборка осуществляется с использованием утилиты [CMake](https://ru.wikipedia.org/wiki/CMake). Для её упрощения вы можете
воспользоваться скриптом [build.sh](build.sh). После его исполнения собранный код будет находиться в директории
build/Debug:

```shell
./build.sh
```
Исполняемый файл будет находиться в папке build/Release. Для запуска в терминале выполнить ./trade_core, предварительно сконфигурировав
файл default_config.toml

### Подготовка к запуску

Всю необходимую для работы информацию ядро получает из файла default_config.toml

Пример файла default_config.toml

```toml
# данные для гейта
[core]
exchange_name = 'exchange_name'
instance_name = '1'
[configuration]
# Откуда загружать конфигурацию. Может быть три значения: agent, api, file.

source = 'api'

# эндпойнт для получения конфигурации от конфигуратора.
api = ["configurator.robotrade.io", "/{exchange_name}/1?only_new=false"]

# настройки работы протокола aeron
[aeron]
# настройки каналов откуда будем принимать данные
[aeron.subscribers]
# настройки канала куда будет приходить конфигурацию от агента
# ["channel", channel_id]       
agent = ["aeron:ipc", 1004]
# настройки каналов куда будем отправлять данные
[aeron.publishers]
# канал куда отправляем логи
logs = ["aeron:ipc", 2002]
# канал агента куда гейт при запуске отправит запрос на получение конфига
agent = ["aeron:ipc", 1002]
```
Поле "source" может иметь три значения:

 - agent (конфигурация будет получена от агента по каналу aeron);
 - api   (конфигурация будет получена непосредственно с сервера конфигуратора (как настроить файл конфигурации смотреть [тут](https://github.com/RoboTradeCode/simple-core/wiki/Core-Configuration)), будет использоваться эндпойнт из примера выше)
 - file  (конфигурация будет получена из файла config.json (настраивается так же, как и на сервере конфигуратора), который должен находиться там же где и default_config.toml)
### Конфигурация ядра

Конфигурация хранится в файле [config.toml](config.toml.example) в формате [TOML](https://ru.wikipedia.org/wiki/TOML).
Ядро будет искать её по относительному пути в рабочей директории. В процессе сборки конфигурация автоматически
копируется к исполняемому файлу.

### Пример конфигурации systemd

Для настройки автоматического перезапуска кода можно запустить его в качестве
сервиса [systemd](https://ru.wikipedia.org/wiki/Systemd). Если имя вашего пользователя `ubuntu`, конфигурация может
выглядеть следующим образом:

```
[Unit]
Description=Trade Core
After=network.target

[Service]
User=ubuntu
WorkingDirectory=/home/ubuntu/trade_core/build/Debug
ExecStart=/home/ubuntu/trade_core/build/Debug/trade_core
Restart=always
RestartSec=3

[Install]
WantedBy=multi-user.target
```

## Логирование

В процессе своей работы ядро генерирует следующие файлы логов:

| Файл                | Содержимое                                                                |
|---------------------|---------------------------------------------------------------------------|
| logs/general.log    | Основные действия при работе ядра                                         |
| logs/balances.log   | Сообщения, поступившие на канал `balances` (баланс связанного шлюза)      |
| logs/orders.log     | Сообщения, которые ядро отправляет в связанный шлюз (ордера)              |
| logs/logs.log       | Сообщения, которые ядро отправляет в лог сервер                           |
| logs/errors.log     | Сообщения об ошибках                                                     |

Содержимое файлов logs/orders.log и logs/general.log для удобства дублируется на стандартный поток вывода.

Ядро отсылает на лог сервер следующую информацию:
 - сообщение о создании ордера;
 - сообщение об отмене ордера;
 
## Алгоритм работы

Входные данные (на примере BTC/USDT):
- пороговые значения: 
    - base_threshold  = 0.0008
    - quote_threshold = 40

- коэффициенты для вычисления цены ордеров:
    - sell_ratio = 1.0015
    - buy_ratio  = 0.9985

- коэффициенты для вычисления границ удержания ордеров:
    - lower_bound_ratio  = 0.9995
    - uppder_bound_ratio = 1.0005

- время для запроса статуса ордера (если по истечении этого времени не приходит ответ от гейта о результате выставлении ордера, то ядро запросит у гейта его статус, а гейт в свою очередь отправит запрос на биржу),

- время для сброса ордера (должно быть болше времени для запроса статуса ордера, если по истечении этого времени нет инфомации об ордере, все данные связанные с этим ордером сбрасываюся и ордер может быть выставлен заново)

Действия:
1. Загружает конфигурацию и получает из нее список ассетов, рынки, коэффициенты, пороговые значения и параметры для создания каналов aeron.
2. Подписывается на канал aeron для получения балансов.
3. Подписывается на канал aeron для получения ордербуков (схема настройки режима Multicast описана [тут](https://github.com/RoboTradeCode/aeron-cpp)).
4. Подписывается на канад aeron для получения статуса ордеров.
5. Посылает команду гейту на отмену всех ордеров.
6. Посылает команду гейту на получение баланса.
7. Получает баланс и запоминает его в словаре, 
   ```
     например:  std::map<std::string, double> _balance, 
   ```
   ключом которого является accет (BTC, USD и т.д.), а значением являются доступные средства.
8. Постоянно получает информацию об ордербуках от гейта (или гейтов) и сохраняет ордербуки в словарь,
   ```
     например: std::map<std::string, std::map<std::string, std::pair<double, double>>> _orderbooks, 
   ```
     ключем которого является биржа (например "ftx"), а значением является тоже словарь, у которого ключ - валютная пара (например "BTC/USDT"), а значением является лучшее ценовое предложение (ask и bid).
9. Вычисляет среднее арифметическое значение ордербуков **avg_ask** и **avg_bid** по конкретной валютной паре (например "BTC/USDT"), т.е. суммирует все ценовые предложения (ask и bid) по отдельности и делит сумму на количество ценовых предложений в валютной паре.
10. Из полученных средних значений выполняет рассчет возможных ордеров по формуле:
    ```
    sell_price = avg_ask * sell_ratio;
    buy_price  = avg_bid * buy_ratio;
    ```
11. Рассчитывает минимальные и максимальные границы из средних значений по формулам:
    ```
    min_ask = avg_ask * lower_bound_ratio;
    max_ask = avg_ask * upper_bound_ratio;
    min_ask = avg_bid * lower_bound_ratio;
    max_ask = avg_bid * upper_bound_ratio;
    ```
12. Проверяет "зависшие" ордера в словаре _clients_id (при создании ордера) по клиентскому идентификатору, [подробнее описано тут](https://github.com/RoboTradeCode/simple-core/wiki/%D0%9A%D0%BB%D0%B8%D0%B5%D0%BD%D1%82%D1%81%D0%BA%D0%B8%D0%B9-%D0%B8%D0%B4%D0%B5%D0%BD%D1%82%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%82%D0%BE%D1%80-%D0%BE%D1%80%D0%B4%D0%B5%D1%80%D0%B0). 
13. Проверяет "зависшие" ордера в словаре _cancel_id (при отмене ордера). В данном случае используется такой же принцип как и проверка по клиентскому идентификатору, только в качестве идентификатора выступает id ордера, который вернула биржа. 
14. Проверяет, есть ли выставленный ордер на продажу и если нет ордера и есть достаточно BTC (т.е. **_balance["BTC"] > base_threshold**), то генерирует клиентский идентификатор ордера, запоминает его и выставлят ордер на продажу по цене **sell_price** и объемом **sell_quantity**, где **sell_quantity** - это доступные средства. После чего ядро запоминает значения **min_ask** и **max_ask** (граница удержания).
15. Проверяет, есть ли выставленный ордер на покупку и если нет ордера и есть достаточно USDT (т.е. **_balance["USDT"] > quote_threshold**), то генерирует клиентский идентификатор ордера, запоминает его и выставлят ордер на покупку по цене **buy_price** и объемом **buy_quantity**, где **buy_quantity** - это значение, вычисленное по формуле: 
```
  buy_quantity = _balance["USDT"] / sell_price. 
```  
  После чего ядро ядро запоминает значения **min_bid** и **max_bid** (граница удержания). 
16. В канале статуса ордеров получает результат выставления ордера и запоминает идентификатор выставленного ордера (который вернула биржа). Удаляет клиентский идентификатор из словаря [_clients_id](https://github.com/RoboTradeCode/simple-core/wiki/%D0%9A%D0%BB%D0%B8%D0%B5%D0%BD%D1%82%D1%81%D0%BA%D0%B8%D0%B9-%D0%B8%D0%B4%D0%B5%D0%BD%D1%82%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%82%D0%BE%D1%80-%D0%BE%D1%80%D0%B4%D0%B5%D1%80%D0%B0) в случае, если ордер создавался, или удаляет идентификатор из словаря _cancel_id в случае, если ордер отменялся.


17. Если есть выставленный ордер на продажу, но усредненное лучшее предложение (**avg_ask**) за пределами границы удержания (т.е. данное условие не выполняется: **(min_ask < avg_ask && avg_ask < max_ask)**), то ядро отменят ордер на покупку по раннее запомненному идентификатору.

18. Если есть выставленный ордер на покупку, но усредненное лучшее предложение (**avg_bid**) за пределами границы удержания (т.е. данное условие не выполняется: **(min_bid < avg_bid && avg_bid < max_bid)**), то ядро отменят ордер на продажу по ранее запомненному идентификатору.

19. Возвращается к пункту 8.

## Формат команды статуса ордеров

Ядро при обнаружении "зависшего" ордера посылает команду гейту с запросом статуса ордера. Ниже представлен формат команды:

````
{
   "event":"command",
   "exchange":"ftx",
   "node":"core",
   "instance": "2",
   "action":"order_status",
   "message":null,
   "algo":"spred_bot",
   "timestamp":1644489501367487,
   "data":{
      "client_id":"6F9619FF-8B86-D011-B42D-00CF4FC964FF"
   }
}
````

Поле data содержит клиентский идентификатор.

Ядро будет работать с другими гейтами, но если гейт не вернет результат выставления ордера в канал статуса ордеров, ядро запросит статус ордера по   истечении опрделенного времени по клиентскому идентификатору и гейт (если не умеет обрабатвыать команды с полем client_id) отправит на биржу запрос с клиентским идентификатор и биржа ответит, что такого ордера нет. Ядро будет считать ордер не действительным и будет расчитывать ордер заново.

#### Блок-схема:
![trade_core](https://user-images.githubusercontent.com/60933744/170728197-693c95eb-d5e3-4aa6-be93-f18466ceee48.jpeg)


